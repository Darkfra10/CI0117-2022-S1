main(argc, argv[]):
  if argc = 8 then
    shared unit_count := integer(argv[1])
    shared producer_count := integer(argv[2])
    shared consumer_count := integer(argv[3])
    shared producer_min_delay := integer(argv[4])
    shared producer_max_delay := integer(argv[5])
    shared consumer_min_delay := integer(argv[6])
    shared consumer_max_delay := integer(argv[7])

    shared queue := create_integer_queue()
    shared can_access_queue := semaphore(1)

    shared can_consume := semaphore(0)

    shared next_unit := 0
    shared can_access_next_unit := semaphore(1)

    shared consumed_count := 0
    shared can_access_consumed_count := semaphore(1)

    create_threads(producer_count, producer)
    create_threads(consumer_count, consumer)
    
  end if

producer:
  while true do
    wait(can_access_next_unit)
      if next_unit >= unit_count then
        signal(can_access_next_unit)
        break while
      end if
      next_unit := next_unit + 1
      my_unit := next_unit
    signal(can_access_next_unit)
    delay(random_between(producer_min_delay, producer_max_delay))
    wait(can_access_queue)
      enqueue(queue, my_unit)
    signal(can_access_queue)
    print("Produced ", my_unit)
    signal(can_consume)
  end while

consumer:
  while true do
    wait(can_access_consumed_count)
      if consumed_count >= unit_count then
        signal(can_access_consumed_count)
        break while
      end if
      consumed_count := consumed_count + 1
    signal(can_access_consumed_count)
    wait(can_consume)
    wait(can_access_queue)
      my_unit := dequeue(queue)
      print("\tConsuming ", my_unit)
    signal(can_access_queue)
    delay(random_between(consumer_min_delay, consumer_max_delay))
  end while

random_between(min, max):
  return min + rand() % (max - min)
